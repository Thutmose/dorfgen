package dorfgen;

import java.util.Set;

import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
import com.mojang.brigadier.suggestion.SuggestionProvider;

import dorfgen.conversion.DorfMap;
import dorfgen.conversion.DorfMap.Region;
import dorfgen.conversion.DorfMap.Site;
import net.minecraft.command.CommandException;
import net.minecraft.command.CommandSource;
import net.minecraft.command.Commands;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.player.ServerPlayerEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.text.StringTextComponent;
import net.minecraftforge.server.permission.DefaultPermissionLevel;
import net.minecraftforge.server.permission.PermissionAPI;

public class DorfCommand
{
    public static boolean hasPerm(final CommandSource source, final String permission)
    {
        try
        {
            final ServerPlayerEntity player = source.asPlayer();
            return DorfCommand.hasPerm(player, permission);
        }
        catch (final CommandSyntaxException e)
        {
            // TODO decide what to actually do here?
            return true;
        }
    }

    public static boolean hasPerm(final ServerPlayerEntity player, final String permission)
    { /*
       * Check if the node is registered, if not, register it as OP, and send
       * error message about this.
       */
        if (!PermissionAPI.getPermissionHandler().getRegisteredNodes().contains(permission))
        {
            final String message = "Autogenerated node, this is a bug and should be pre-registered.";
            PermissionAPI.getPermissionHandler().registerNode(permission, DefaultPermissionLevel.OP, message);
            System.err.println(message + ": " + permission);
        }
        return PermissionAPI.hasPermission(player, permission);
    }

    private static SuggestionProvider<CommandSource> SUGGESTSITES = (ctx,
            sb) -> net.minecraft.command.ISuggestionProvider.suggest(Dorfgen.instance.getDorfs(ctx.getSource()
                    .getWorld()).sitesByName.keySet(), sb);

    public static void register(final CommandDispatcher<CommandSource> commandDispatcher)
    {
        String name = "dorfgen";
        final String perm_base;
        PermissionAPI.registerNode(perm_base = "command." + name, DefaultPermissionLevel.ALL, "Can the player use /"
                + name);

        final String perm_info;
        PermissionAPI.registerNode(perm_info = "command." + name + ".info", DefaultPermissionLevel.ALL,
                "Can the player use /" + name);
        final LiteralArgumentBuilder<CommandSource> info = Commands.literal("info").requires(cs -> DorfCommand.hasPerm(
                cs, perm_info)).executes((ctx) -> DorfCommand.info(ctx.getSource()));
        final String perm_tp;
        PermissionAPI.registerNode(perm_tp = "command." + name + ".tp", DefaultPermissionLevel.OP,
                "Can the player use /" + name);
        final LiteralArgumentBuilder<CommandSource> tp = Commands.literal("tp").requires(cs -> DorfCommand.hasPerm(cs,
                perm_tp)).then(Commands.argument("site", StringArgumentType.greedyString()).suggests(
                        DorfCommand.SUGGESTSITES).executes((ctx) -> DorfCommand.tp(ctx.getSource(), StringArgumentType
                                .getString(ctx, "site"))));
        LiteralArgumentBuilder<CommandSource> command;

        command = Commands.literal(name).requires(cs -> DorfCommand.hasPerm(cs, perm_base)).then(info).then(tp);
        commandDispatcher.register(command);
        name = "df";
        command = Commands.literal(name).requires(cs -> DorfCommand.hasPerm(cs, perm_base)).then(info).then(tp);
        commandDispatcher.register(command);
    }

    private static int info(final CommandSource source) throws CommandSyntaxException
    {
        final PlayerEntity player = source.asPlayer();
        final BlockPos pos = player.getPosition();
        final DorfMap dorfs = Dorfgen.instance.getDorfs(player.getEntityWorld());
        final Region region = dorfs.getRegionForCoords(pos.getX(), pos.getZ());
        final Set<Site> sites = dorfs.getSiteForCoords(pos.getX(), pos.getZ());
        String message = "Region: " + region.toString();
        for (final Site site : sites)
            message += ", Site: " + site;
        player.sendMessage(new StringTextComponent(message));
        return 0;
    }

    private static int tp(final CommandSource source, final String name) throws CommandSyntaxException
    {
        final PlayerEntity player = source.asPlayer();
        final DorfMap dorfs = Dorfgen.instance.getDorfs(player.getEntityWorld());
        final Site site = dorfs.sitesByName.get(name);
        if (site == null) throw new CommandException(new StringTextComponent("no site " + name));
        final int x = site.x * dorfs.scale + dorfs.scale;
        final int z = site.z * dorfs.scale + dorfs.scale;
        final int relx = x - Dorfgen.shift.getX();
        final int relz = z - Dorfgen.shift.getZ();
        final int y = dorfs.biomeInterpolator.interpolate(dorfs.elevationMap, relx, relz, dorfs.scale) + 10;
        player.sendMessage(new StringTextComponent("Teleported to " + site));
        player.setPositionAndUpdate(x, y, z);
        return 0;
    }
}
